#!usr/bin/python env
# coding: utf-8
__doc__ = "Interface avec CM V2"
__version__ = "3.0.1"

from beaker.middleware import SessionMiddleware
import bottle
from bottle import static_file
#~ from bottle import route, post, get, redirect, abort, request, app
from bottle import TEMPLATE_PATH, jinja2_template as template

import os
import json
from bson import json_util
from bson.json_util import dumps
from convert import Connector, MongoClient
from cortext_api import *


# # App configuration # #
HOST = "localhost"
PORT = 8000
app = bottle.app()
session_opts = {
    'session.cookie_expires': True,
    'session.encrypt_key': 'please use a random key and keep it secret!',
    'session.httponly': True,
    'session.timeout': 3600 * 24, # 1 day
    'session.type': 'cookie',
    'session.validate_key': True,
    }
#plugin = MongoPlugin(uri="mongodb://127.0.0.1", db="1", json_mongo=True)
#app.install(plugin)

app = SessionMiddleware(app, session_opts)


#directory for the project
PROJECT_PATH = os.getcwd()
DEBUG = True
host = "localhost"
port = 8000

#from jinja2 import Environment, FileSystemLoader, TemplateNotFound

TEMPLATE_PATH = os.path.join(PROJECT_PATH,'views')


    
def run_app(host="localhost", port=8000):
    '''main function for running the app >>> into python scheduler    
    '''
    bottle.debug(DEBUG)
    
    #bottle.TEMPLATE_PATH.insert(0,os.path.join(PROJECT_PATH,'views'))
    #bottle.STATIC_PATH = os.path.join(PROJECT_PATH,'static')
    #bottle.STATIC_PATH = PROJECT_PATH
    bottle.RESULT_PATH = os.path.join(PROJECT_PATH,'data')
    bottle.data_store = os.path.join(PROJECT_PATH,'data_store')
    #bottle.env = Environment(loader=FileSystemLoader(bottle.TEMPLATE_PATH))
    bottle.run(app=app, quiet=False, reloader=True, host=host, port=port)
    

@bottle.get('/static/<filename:re:.*\.js>')
def javascripts(filename):
    return static_file(filename, root='static/js')

@bottle.get('/static/<filename:re:.*\.css>')
def stylesheets(filename):
    return static_file(filename, root='static/css')

@bottle.get('/static/<filename:re:.*\.(jpg|png|gif|ico)>')
def images(filename):
    return static_file(filename, root='static/img')

@bottle.get("/update/<db_name>/<doc_id>")
def update(db_name, doc_id):
    b_path = os.path.join(bottle.data_store, db_name)
    c = Connector(db_path)
    new_data = request.get("row")
    #data = c.format_data()
    doc = c.data.update_one({"_id":doc_id}, {"$set":new_data})
    if doc is not None:
        return True
    return False

@bottle.get("/delete/<db_name>/<doc_id>")
def delete(db_name, doc_id):
    db_path = os.path.join(bottle.data_store, db_name)
    c = Connector(db_path)
    new_data = request.get("row")
    #data = c.format_data()
    doc = c.data.remove_one({"_id": doc_id})
    if doc is not None:
        return True
    return False

@bottle.get("/add_row/<db_name>")
def add_row(db_name, doc_id):
    db_path = os.path.join(bottle.data_store, db_name)
    c = Connector(db_path)
    new_data = request.get("row")
    #data = c.format_data()
    doc = c.data.insert_one(new_data)
    if doc is not None:
        return True
    return False

@bottle.get("/add_column/<db_name>")
def add_col(db_name, doc_id):
    db_path = os.path.join(bottle.data_store, db_name)
    c = Connector(db_path)
    new_data = request.get("row")
    #data = c.format_data()
    for item in c.data.find():
        doc = c.data.update_one({"_id":item["_id"]}, {"$set":new_data})
    doc = c.data.count(new_data)
    if doc  > 0:
        return True
    return False
    
@bottle.get("/load/<db_name>")
def serve_data(db_name):
    #name = db_name.replace(".db", "")
    db_path = os.path.join(bottle.data_store, db_name)
    c = Connector(db_path)
    return json.dumps({"data":[n for n in c.data.find({},{"_id":False})]})
    
@bottle.get("/edit/<hashkey>")
def antonio(hashkey):
    ''' Main access to editor that takes 1 hashkey, 2 callback, 1 accessToken
    located at antonio.cortext.net
    '''
    '''
    #check if all the parameters are correctly sent
    if len(set(request.query.keys())  - set(["callback_json", "callback_url", "accessToken"])) == 0:
        #~ #localhost:8000/edit/daL5E9CCgLaASf8rF?accessToken=86305983c72a0e9865ceca050cf6a2f1ee7cdfc6&callback_json=http://lisis-srv-mgr.u-pem.fr:8080/project/126/analysis&callback_url=http://lisis-srv-mgr.u-pem.fr:8080/project/126/analysis
        callback_json = request.query.callback_json
        callback_url = request.query.callback_url
        access_token = request.query.accessToken
        return antonio(access_token, hashkey, callback_json, callback_url)
    '''
    
    #1. appel oauth: demande de droit d'accès
    #user =  get_oauth(access_token)
    #2. appel à assets: demande droit de modification (read-only, read-and-write)
    #locked = lock_file(hashkey, token)
    #3. appel à assets: récupérer les metadonnées du fichier pour le nom de la base et le nom des tables
    #http://assets.cortext.net/docs/f7ef64c1ded0dc2f831ec34089ffc2d2
    config = get_metadata(hashkey="f7ef64c1ded0dc2f831ec34089ffc2d2", access_token=None)
    if isinstance(config, dict):
        data = get_data(hashkey="f7ef64c1ded0dc2f831ec34089ffc2d2",db = config["db_name"], access_token=None)
    else:
        return template("400.tpl", status_code="404", error_msg="Connexion error: unable to get metadata on the doc: assets.cortext.net is unreachable")
    config["hashkey"] = hashkey
    db_path = os.path.join(bottle.data_store, config["db_name"])
    
    c = Connector(db_path)
    c.convert()
    header = c.data.find_one({},{"_id":False}).keys()
    config["locked"] = True
    if config["locked"]:
        #print ">>>", config["db_name"]
        return template("simple.tpl", db_name = config["db_name"], header = header, columns = [{"data": str(n)} for n in header])
        

    
if __name__ == "__main__":
    run_app()
